Scrivere un algoritmo che, dato un grafo G non orientato, un nodo di partenza s, un nodo
di arrivo t, con s diverso da t, ed un array P di nodi "preferiti", dice se esiste un cammino da s
a t che tocca almeno un nodo dell'insieme P. Qual è la complessità dell’algoritmo ideato?

PASSI:
	1.	Esegui una BFS/DFS da s.
        → Trova l’insieme R_s dei nodi raggiungibili da s.
	2.	Se t \notin R_s, restituisci No (non c’è alcun cammino).
	3.	Altrimenti controlla se R_s \cap P \neq \emptyset.
	    Se sì → Sì.
	    Se no → No.


PSEUDO:
function check_path_with_P(G, s, t, P):
    visited ← array[|V|] inizializzato a false
    queue ← [s]
    visited[s] ← true

    while queue non vuota:
        u ← pop(queue)
        for v in Adj[u]:
            if not visited[v]:
                visited[v] ← true
                push(queue, v)

    if not visited[t]:
        return "No"   // t non è raggiungibile da s

    for p in P:
        if visited[p]:
            return "Sì"  // trovato un nodo preferito lungo qualche cammino
    return "No"